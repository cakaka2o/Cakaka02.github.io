
// mapeo_check.js - EmojÃ­aco client mapper (slashes support)
async function loadMapping() { const r = await fetch('mapping.json'); if(!r.ok) throw new Error('mapping.json not loaded'); return r.json(); }
function buildReverse(mapping) { const rev = Object.create(null); for(const k in mapping) rev[mapping[k]] = k; return rev; }
function textToEmoji(text, mappingData, opts={}) { const map = mappingData.mapping; const U = mappingData.upper_marker || 'ðŸ‘€'; const include_n = opts.include_n !== undefined ? opts.include_n : true; const use_slash = opts.use_slash || false; const keep_unknown = opts.keep_unknown !== undefined ? opts.keep_unknown : true; const lines = text.split('\n'); const parts = []; for(const ln of lines){ const words = ln.split(/\s+/).filter(Boolean); const emWords = []; for(const w of words){ let em=''; for(const ch of w){ let key = ch.toLowerCase(); if(key==='Ã±' && !include_n) key='n'; if(map[key]){ em += map[key] + (ch === ch.toUpperCase() && /[A-Z]/i.test(ch) ? U : ''); } else { if(keep_unknown) em += ch; } } emWords.push(em);} parts.push(use_slash ? emWords.join(' / ') : emWords.join(' ')); } return use_slash ? parts.join(' // ') : parts.join('\n'); }
function emojiToText(emojiText, mappingData, opts={}) { const map = mappingData.mapping; const rev = buildReverse(map); const U = mappingData.upper_marker || 'ðŸ‘€'; const include_n = opts.include_n !== undefined ? opts.include_n : true; const keep_unknown = opts.keep_unknown !== undefined ? opts.keep_unknown : true; let i=0, out=''; const tokens = Object.keys(rev).sort((a,b)=>b.length-a.length); const tokensUp = tokens.map(t=>t+U); while(i < emojiText.length){ if(emojiText.startsWith(' // ', i)){ out += '\n'; i += 4; continue; } if(emojiText.startsWith('//', i)){ out += '\n'; i += 2; continue; } if(emojiText.startsWith(' / ', i)){ out += ' '; i += 3; continue; } if(emojiText.startsWith('/', i)){ out += ' '; i += 1; continue; } let matched=false; for(const t of tokensUp){ if(emojiText.startsWith(t, i)){ const base = t.slice(0, -U.length); const ch = rev[base]; out += ch ? ch.toUpperCase() : (keep_unknown ? t : ''); i += t.length; matched=true; break; } } if(matched) continue; for(const t of tokens){ if(emojiText.startsWith(t, i)){ const ch = rev[t]; out += ch ? ch : (keep_unknown ? t : ''); i += t.length; matched=true; break; } } if(matched) continue; out += emojiText[i]; i++; } if(!include_n) out = out.replace(/Ã±/g,'n').replace(/Ã‘/g,'N'); return out; }
if(typeof window !== 'undefined') window.Emojaco = Object.assign(window.Emojaco || {}, { loadMapping, textToEmoji, emojiToText });
if(typeof module !== 'undefined') module.exports = { textToEmoji, emojiToText };
